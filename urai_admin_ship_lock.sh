#!/bin/bash\nset -euo pipefail\n\n# --- CONFIGURATION ---\nTIMESTAMP=$(date +\"%Y%m%dT%H%M%S\")\nPROJECT_ID=\"urai-admin\"\nREPO_ROOT=\"\"\nLOG_FILE=\"/tmp/${PROJECT_ID}_ship_lock_${TIMESTAMP}.log\"\nEMULATOR_PID_GROUP=\"\"\nexport NVM_DIR=\"$HOME/.nvm\"\nNODE_VERSION=\"20\"\n\n# --- LOGGING ---\nexec > >(tee -a \"$LOG_FILE\") 2>&1\necho \"LOG=START: Firebase Studio Shipmaster for ${PROJECT_ID} - ${TIMESTAMP}\"\n\n# --- UTILITY FUNCTIONS ---\nwait_for_port() {\n  local name=$1\n  local port=$2\n  local host=$3\n  local timeout=180 # Increased timeout for slower CI environments\n  local start_time=$(date +%s)\n  echo \"LOG=INFO: Waiting up to ${timeout}s for ${name} on ${host}:${port} to be open...\"\n  while ! ( exec 3<>/dev/tcp/\"$host\"/\"$port\") 2>/dev/null; do\n    if [ $(($(date +%s) - start_time)) -ge $timeout ]; then\n      echo \"LOG=ERROR: Timeout waiting for ${name} on port ${port}.\" >&2\n      if [ -f \"emulator-debug.log\" ]; then\n          echo \"LOG=INFO: Dumping emulator-debug.log...\"\n          cat emulator-debug.log\n      fi\n      exit 1\n    fi\n    sleep 5\n  done\n  # Close the file descriptor\n  exec 3<&-\n  exec 3>&-\n  echo \"LOG=SUCCESS: ${name} is ready on port ${port}.\"\n}\n\n# --- CLEANUP ---\ncleanup() {\n  local exit_code=$?\n  echo \"LOG=CLEANUP: Starting cleanup with exit code $exit_code...\"\n  if [ -n \"$EMULATOR_PID_GROUP\" ]; then\n    echo \"LOG=CLEANUP: Stopping Firebase Emulators (PID Group: $EMULATOR_PID_GROUP)...\"\n    # Kill the entire process group to ensure all child processes are terminated\n    kill -9 \"-$EMULATOR_PID_GROUP\" 2>/dev/null || true\n  fi\n  if [ $exit_code -ne 0 ]; then\n    echo \"LOG=FAIL: Script failed. See log for details: $LOG_FILE\"\n  fi\n  echo \"LOG=CLEANUP: Done.\"\n  echo \"LOG=END: Script finished.\"\n}\ntrap cleanup EXIT INT TERM\n\n# --- PREREQUISITES CHECK AND INSTALLATION ---\necho \"LOG=INFO: STEP 1: Checking for required tools...\"\nfor cmd in curl jq; do\n    if ! command -v \"$cmd\" &> /dev/null; then\n        echo \"LOG=ERROR: Required command '$cmd' not found in PATH. Please install it.\" >&2\n        exit 1\n    fi\ndone\necho \"LOG=SUCCESS: Found curl and jq.\"\n\n# Gracefully handle NVM installation\necho \"LOG=INFO: STEP 2: Setting up Node.js environment via NVM...\"\nif [ ! -s \"$NVM_DIR/nvm.sh\" ]; then\n    echo \"LOG=INFO: NVM not found, installing...\"\n    set +e\n    curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash\n    NVM_INSTALL_EXIT_CODE=$?\n    set -e\n    if [ $NVM_INSTALL_EXIT_CODE -ne 0 ] && [ $NVM_INSTALL_EXIT_CODE -ne 1 ]; then\n        echo \"LOG=ERROR: NVM installation failed with unexpected exit code $NVM_INSTALL_EXIT_CODE\"\n        exit 1\n    fi\n    echo \"LOG=SUCCESS: NVM installed.\"\nfi\n\n# Source NVM and install/use Node, pnpm, firebase-tools\nsource \"$NVM_DIR/nvm.sh\"\necho \"LOG=INFO: Sourced NVM. Installing Node.js v${NODE_VERSION}...\"\n\nnvm install \"$NODE_VERSION\"\nnvm use \"$NODE_VERSION\"\nnvm alias default \"$NODE_VERSION\"\necho \"LOG=SUCCESS: Now using Node.js v$(node --version) and npm v$(npm --version).\"\n\nif ! command -v \"pnpm\" &> /dev/null; then\n    echo \"LOG=INFO: pnpm not found, installing globally...\"\n    npm install -g pnpm\n    echo \"LOG=SUCCESS: pnpm installed.\"\nfi\n\nif ! command -v \"firebase\" &> /dev/null; then\n    echo \"LOG=INFO: firebase-tools not found, installing globally...\"\n    npm install -g firebase-tools\n    echo \"LOG=SUCCESS: firebase-tools installed.\"\nfi\n\necho \"LOG=SUCCESS: All prerequisite tools are present.\"\n\n# --- REPO DISCOVERY ---\necho \"LOG=INFO: STEP 3: Discovering project repo root...\"\nCANDIDATE_DIR=$(find /home/user -maxdepth 3 -type f -name firebase.json -exec grep -l \"\\\"${PROJECT_ID}\\\"\" {} + | xargs -r dirname | head -n 1)\n\nif [ -z \"$CANDIDATE_DIR\" ]; then\n    CANDIDATE_DIR=$(find /home/user -maxdepth 3 -type f -name .firebaserc -exec grep -l \"\\\"${PROJECT_ID}\\\"\" {} + | xargs -r dirname | head -n 1)\n    if [ -n \"$CANDIDATE_DIR\" ]; then\n      echo \"LOG=INFO: Found repo root via .firebaserc\"\n    fi\nelse\n    echo \"LOG=INFO: Found repo root via firebase.json\"\nfi\n\nif [ -z \"$CANDIDATE_DIR\" ]; then\n    echo \"LOG=ERROR: Could not find a valid repo root for project '${PROJECT_ID}' under /home/user.\" >&2\n    exit 1\nfi\nREPO_ROOT=$(realpath \"$CANDIDATE_DIR\")\ncd \"$REPO_ROOT\"\necho \"LOG=SUCCESS: Changed directory to repo root: ${REPO_ROOT}\"\n\n# --- FIREBASE LOGIN & PROJECT CHECK ---\necho \"LOG=INFO: STEP 4: Verifying Firebase CLI login and project...\"\nif ! firebase login:list --json | jq -e \'.result.user\' > /dev/null; then\n    echo \"LOG=ERROR: No user is logged into the Firebase CLI. Please run \\`firebase login\\`.\" >&2\n    exit 1\nfi\nfirebase use \"$PROJECT_ID\"\necho \"LOG=SUCCESS: Firebase user logged in and project set to '${PROJECT_ID}'.\"\n\n# --- BACKUPS ---\necho \"LOG=INFO: STEP 5: Creating timestamped backups...\"\nBACKUP_DIR=\"${REPO_ROOT}/urai_backups/${TIMESTAMP}\"\nmkdir -p \"$BACKUP_DIR/apps/urai-admin/src\" \"$BACKUP_DIR/functions/src\"\ncp firebase.json \"$BACKUP_DIR/firebase.json.bak\"\n[ -f \"pnpm-lock.yaml\" ] && cp pnpm-lock.yaml \"$BACKUP_DIR/pnpm-lock.yaml.bak\" || true\n[ -f \"firestore.rules\" ] && cp firestore.rules \"$BACKUP_DIR/firestore.rules.bak\" || true\n[ -f \"storage.rules\" ] && cp storage.rules \"$BACKUP_DIR/storage.rules.bak\" || true\n[ -f \"apps/urai-admin/src/middleware.ts\" ] && cp \"apps/urai-admin/src/middleware.ts\" \"$BACKUP_DIR/apps/urai-admin/src/middleware.ts.bak\" || true\n[ -f \"functions/src/index.ts\" ] && cp \"functions/src/index.ts\" \"$BACKUP_DIR/functions/src/index.ts.bak\" || true\necho \"LOG=SUCCESS: Backups created in ${BACKUP_DIR}\"\n\n# --- DEPENDENCIES and ENV ---\necho \"LOG=INFO: STEP 6: Installing project dependencies...\"\npnpm install\necho \"LOG=INFO: Creating .env.local for the Next.js app...\"\nmkdir -p apps/urai-admin\ncat << EOF > apps/urai-admin/.env.local\nNEXT_PUBLIC_FIREBASE_PROJECT_ID=${PROJECT_ID}\nEOF\necho \"LOG=SUCCESS: Dependencies installed.\"\n\n# --- SECURITY HARDENING ---\necho \"LOG=INFO: STEP 7: Hardening security configurations...\"\n\necho \"LOG=INFO: Hardening firebase.json for secure hosting rewrite...\"\njq \'.hosting.rewrites = [\n  {\n    \"source\": \"/admin{,/**}\",\n    \"function\": \"verifyAuth\"\n  },\n  {\n    \"source\": \"/**\",\n    \"destination\": \"/index.html\"\n  }\n]\' firebase.json > firebase.json.tmp && mv firebase.json.tmp firebase.json\necho \"LOG=SUCCESS: firebase.json hardened.\"\n\necho \"LOG=INFO: Hardening Next.js middleware (Defense-in-Depth)...\"\ncat << 'EOF' > apps/urai-admin/src/middleware.ts\nimport { NextResponse } from \'next/server\';\nimport type { NextRequest } from \'next/server\';\n\nexport function middleware(request: NextRequest) {\n  // This header is expected to be added by the \'verifyAuth\' Cloud Function.\n  // Its absence implies the gatekeeper was bypassed.\n  if (!request.headers.get(\'x-authenticated-user\')) {\n    const loginUrl = new URL(\'/login\', request.url);\n    console.error(\'[Middleware] CRITICAL: Missing x-authenticated-user header. Redirecting to login.\');\n    return NextResponse.redirect(loginUrl);\n  }\n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: \'/admin/:path*\',\n};\nEOF\necho \"LOG=SUCCESS: Admin middleware hardened.\"\n\necho \"LOG=INFO: Hardening Firestore and Storage security rules...\"\ncat << 'EOF' > firestore.rules\nrules_version = \'2\';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // A user is an admin if their token has the \'admin\' custom claim.\n    function isAdmin() {\n      return request.auth != null && request.auth.token.admin == true;\n    }\n\n    // Admin collections are only accessible by admins.\n    match /admin-data/{docId=**} {\n      allow read, write: if isAdmin();\n    }\n\n    // For safety, all other collections are locked down by default.\n    match /{document=**} {\n      allow read, write: if false;\n    }\n  }\n}\nEOF\ncat << 'EOF' > storage.rules\nrules_version = \'2\';\nservice firebase.storage {\n  match /b/{bucket}/o {\n    // For safety, only authenticated admins can access any file.\n    match /{allPaths=**} {\n      allow read, write: if request.auth != null && request.auth.token.admin == true;\n    }\n  }\n}\nEOF\necho \"LOG=SUCCESS: Security rules hardened.\"\n\necho \"LOG=INFO: Hardening Cloud Functions (verifyAuth gatekeeper and healthCheck)...\"\nmkdir -p functions/src\ncat << 'EOF' > functions/src/index.ts\nimport { https } from \"firebase-functions\";\nimport * as admin from \"firebase-admin\";\n\nadmin.initializeApp();\n\n// This function is the primary gatekeeper for the entire admin section.\n// It is triggered by the rewrite rule in firebase.json.\nexport const verifyAuth = https.onRequest(async (req, res) => {\n  const sessionCookie = req.cookies.__session || \'\';\n\n  try {\n    // Verify the session cookie. This throws an error if invalid.\n    const decodedToken = await admin.auth().verifySessionCookie(sessionCookie, true);\n\n    // Verify the user has the admin custom claim.\n    if (decodedToken.admin !== true) {\n      console.warn(`[verifyAuth] Non-admin user \'${decodedToken.uid}\' tried to access admin route.`);\n      // Not an admin, so redirect to a safe page.\n      res.redirect(302, \'/not-authorized\');\n      return;\n    }\n\n    // The user is an authenticated admin. The key step is to tell Firebase Hosting\n    // that this check passed so it can proceed to serve the actual Next.js app.\n    // We do this by adding a custom header that the Next.js middleware can check as a\n    // defense-in-depth measure. Then we end the function, but instead of redirecting,\n    // we allow the request to fall through to the next rewrite rule (destination: /index.html).\n    // To do this, we need to end the function without sending a response body.\n    res.setHeader(\'x-authenticated-user\', decodedToken.uid);\n    // By not calling res.send(), res.redirect(), or res.end(), we allow hosting to proceed.\n    // IMPORTANT: This behavior is specific to the V1 runtime with hosting rewrites.\n    // In V2, you would need to handle this differently.\n    // For maximum clarity and to prevent the function from timing out, we end the request\n    // with a status that signals success to Hosting without redirecting.\n    res.status(200).send();\n\n  } catch (error) {\n    // Session cookie is invalid, expired, or doesn\'t exist.\n    // This is the expected path for any unauthenticated user.\n    console.log(\'[verifyAuth] Unauthenticated user detected, redirecting to /login.\');\n    res.redirect(302, \'/login\');\n  }\n});\n\n// A sample callable function that demonstrates checking for admin privileges.\nexport const healthCheck = https.onCall((data, context) => {\n  if (context.auth?.token?.admin !== true) {\n    throw new https.HttpsError(\'permission-denied\', \'You must be an admin to call this function.\');\n  }\n  // If the check passes, return a success message.\n  return { status: \"ok\", timestamp: new Date().toISOString() };\n});\nEOF\necho \"LOG=SUCCESS: Cloud Functions hardened.\"\n\n# --- TESTS ---\necho \"LOG=INFO: STEP 8: Running automated builds and tests...\"\npnpm typecheck\npnpm --filter=urai-admin build\npnpm --filter=functions build\necho \"LOG=SUCCESS: All builds and tests passed.\"\n\n# --- EMULATORS ---\necho \"LOG=INFO: STEP 9: Configuring and starting Firebase Emulators...\"\nHOST_IP=\"127.0.0.1\"\njq --arg host \"$HOST_IP\" \\\n   \'.emulators.auth.host = $host | .emulators.firestore.host = $host | .emulators.functions.host = $host | .emulators.hosting.host = $host | .emulators.ui.host = $host\' \\\n   firebase.json > fb.tmp && mv fb.tmp firebase.json\n\nAUTH_PORT=$(jq -r \'.emulators.auth.port // 9099\' firebase.json)\nFIRESTORE_PORT=$(jq -r \'.emulators.firestore.port // 8080\' firebase.json)\nHOSTING_PORT=$(jq -r \'.emulators.hosting.port // 5000\' firebase.json)\nFUNCTIONS_PORT=$(jq -r \'.emulators.functions.port // 5001\' firebase.json)\nUI_PORT=$(jq -r \'.emulators.ui.port // 4000\' firebase.json)\n\nEMULATOR_IMPORT_FLAG=\"\"\n[ -d \"./.firebase-emulator-data\" ] && EMULATOR_IMPORT_FLAG=\"--import=./.firebase-emulator-data\"\n\n(set -m; firebase emulators:start --project \"${PROJECT_ID}\" ${EMULATOR_IMPORT_FLAG} --export-on-exit=./.firebase-emulator-data &> emulator-debug.log &)\nEMULATOR_PID_GROUP=$!\necho \"LOG=INFO: Emulators starting in background (PID Group: $EMULATOR_PID_GROUP). Log: emulator-debug.log\"\n\nwait_for_port \"Auth Emulator\" \"$AUTH_PORT\" \"$HOST_IP\"\nwait_for_port \"Firestore Emulator\" \"$FIRESTORE_PORT\" \"$HOST_IP\"\nwait_for_port \"Functions Emulator\" \"$FUNCTIONS_PORT\" \"$HOST_IP\"\nwait_for_port \"Hosting Emulator\" \"$HOSTING_PORT\" \"$HOST_IP\"\nwait_for_port \"UI Emulator\" \"$UI_PORT\" \"$HOST_IP\"\n\necho \"LOG=INFO: Running emulator smoke tests...\"\necho \"LOG=TEST: Verifying /login page is accessible on http://${HOST_IP}:${HOSTING_PORT}/login\"\ncurl --fail --silent --show-error --max-time 15 \"http://${HOST_IP}:${HOSTING_PORT}/login\" > /dev/null\necho \"LOG=SUCCESS: Login page loaded.\"\n\necho \"LOG=TEST: Verifying /admin redirects to /login when unauthenticated...\"\nREDIRECT_URL=$(curl --silent --max-time 15 -o /dev/null -L -w \"%{url_effective}\" \"http://${HOST_IP}:${HOSTING_PORT}/admin\")\nif [[ ! \"$REDIRECT_URL\" =~ /login ]]; then\n  echo \"LOG=ERROR: Emulator smoke test failed. /admin did not redirect to /login. Final URL: $REDIRECT_URL\" >&2\n  exit 1\nfi\necho \"LOG=SUCCESS: Admin redirect test passed.\"\necho \"LOG=INFO: Stopping emulators...\"\nkill -9 \"-$EMULATOR_PID_GROUP\"\nwait \"$EMULATOR_PID_GROUP\" || true\nEMULATOR_PID_GROUP=\"\"\necho \"LOG=SUCCESS: Emulators stopped cleanly.\"\n\n# --- DEPLOYMENT ---\necho \"LOG=INFO: STEP 10: Starting deployment to Firebase project: ${PROJECT_ID}...\"\nfirebase deploy --only hosting,functions,firestore,storage --force\necho \"LOG=SUCCESS: Deployment completed.\"\n\n# --- POST-DEPLOYMENT VERIFICATION ---\necho \"LOG=INFO: STEP 11: Verifying live deployment...\"\nHOSTING_URL=$(firebase hosting:sites:list --json | jq -r --arg project \"$PROJECT_ID\" \'.result.sites[] | select(.name | endswith(\"/\" + $project)) | .defaultUrl\')\nif [ -z \"$HOSTING_URL\" ] || [ \"$HOSTING_URL\" == \"null\" ]; then\n    echo \"LOG=ERROR: Could not retrieve default hosting URL after deployment.\" >&2\n    exit 1\nfi\necho \"LOG=INFO: Hosting URL is ${HOSTING_URL}\"\necho \"LOG=INFO: Waiting 60s for deployment to fully propagate...\"\nsleep 60\n\necho \"LOG=TEST: Verifying live login page is accessible...\"\ncurl --fail --silent --show-error -L --max-time 30 \"${HOSTING_URL}/login\" > /dev/null\necho \"LOG=SUCCESS: Live login page is accessible.\"\n\necho \"LOG=TEST: Verifying live /admin redirects to login...\"\nLIVE_REDIRECT_URL=$(curl --silent -L -o /dev/null -w \"%{url_effective}\" \"${HOSTING_URL}/admin\")\nif [[ ! \"$LIVE_REDIRECT_URL\" =~ /login ]]; then\n  echo \"LOG=ERROR: Live site verification failed. /admin did not redirect to login. Final URL: $LIVE_REDIRECT_URL\" >&2\n  exit 1\nfi\necho \"LOG=SUCCESS: Live admin redirect works as expected.\"\n\n# --- LOCK FILE ---\necho \"LOG=INFO: STEP 12: Creating lock file: URAI_ADMIN_LOCK.md...\"\ncat << EOF > URAI_ADMIN_LOCK.md\n# FIREBASE STUDIO SHIPMASTER â€” URAI Admin LOCK\n\nThis file marks a successful and hardened deployment of the URAI Admin project.\nDo not modify this file manually. Re-run \`bash urai_admin_ship_lock.sh\` to update.\n\n- **Project ID:** ${PROJECT_ID}\n- **Deployed URL(s):**\n  - Hosting: ${HOSTING_URL}\n- **Admin Enforcement Mechanism:**\n  - **1. Hosting Rewrite (Edge Gatekeeper):** All requests to \`/admin/**\` are intercepted by Firebase Hosting and rewritten to the \`verifyAuth\` Cloud Function. This is the primary, most secure enforcement point.\n  - **2. Cloud Function (Token Verification):** The \`verifyAuth\` function inspects the user's \`__session\` cookie. If the user has a valid session and an \`admin:true\` custom claim, the function exits with a 200 OK. This signals to Hosting that the check passed, and Hosting proceeds to serve the requested Next.js page. If authentication fails, the function redirects the user to \`/login\` or \`/not-authorized\` at the edge, before the Next.js app is ever invoked for the request.\n  - **3. Next.js Middleware (Defense-in-Depth):** The \`verifyAuth\` function adds a special \`x-authenticated-user\` header to the request before allowing it to proceed. The Next.js middleware for \`/admin/**\` routes verifies this header's presence. If it's missing (indicating a potential bypass of the gatekeeper), it forces a redirect to \`/login\` as a fallback.\n  - **4. Firestore & Storage Rules (Data Layer):** All data access rules for admin-only collections and storage paths explicitly require an authenticated user with a valid Firebase Auth token containing the \`\"admin\": true\` custom claim.\n- **Emulator Ports (from last run):**\n  - Auth: ${HOST_IP}:${AUTH_PORT}\n  - Firestore: ${HOST_IP}:${FIRESTORE_PORT}\n  - Functions: ${HOST_IP}:${FUNCTIONS_PORT}\n  - Hosting: ${HOST_IP}:${HOSTING_PORT}\n- **Tests Run & Passed:**\n  - [X] Prerequisite Checks (curl, jq, nvm, pnpm, firebase-tools)\n  - [X] pnpm typecheck\n  - [X] pnpm --filter=urai-admin build\n  - [X] pnpm --filter=functions build\n  - [X] Emulator Smoke Test: Hosting /login (Loads OK)\n  - [X] Emulator Smoke Test: /admin redirects to /login\n  - [X] Live Site Test: Hosting /login (Loads OK)\n  - [X] Live Site Test: /admin redirects to /login\n- **Re-run Canary Commands:**\n  - \`curl -I ${HOSTING_URL}/login\` (Should return 200 OK)\n  - \`curl -I -L ${HOSTING_URL}/admin\` (Should show a 3xx redirect to a login page)\n\n**LOCKED AT: ${TIMESTAMP}**\nEOF\n\necho \"LOG=SUCCESS: Lock file created.\"\necho \"LOG=DONE\"\n